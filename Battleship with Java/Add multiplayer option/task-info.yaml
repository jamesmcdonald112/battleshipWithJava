type: edu
files:
  - name: test/Tests.java
    visible: false
    text: |-
      import org.hyperskill.hstest.dynamic.DynamicTest;
      import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
      import org.hyperskill.hstest.stage.StageTest;
      import org.hyperskill.hstest.testcase.CheckResult;
      import org.hyperskill.hstest.testing.TestedProgram;
      
      
      public class Tests extends StageTest<String> {
        @DynamicTest
        CheckResult testExample() {
      
          TestedProgram main = new TestedProgram();
          main.feedbackOnException(OutOfMemoryError.class, "Your program threw an OutOfMemoryError. Make sure there are no memory leaks in your code.");
          String output = main.start().trim();
          String[][] matrix;
      
          if (!matrixIsEmpty(getFieldMatrix(output))) {
            return CheckResult.wrong("Not an empty game field at the start of the game");
          }
      
          // Filling the first player field
          if (!output.toLowerCase().contains("aircraft carrier")) {
            return CheckResult.wrong("After starting the program, you should request " +
                    "the coordinates of the Aircraft Carrier in that way:\n" +
                    "\"Enter the coordinates of the Aircraft Carrier (5 cells):\"");
          }
      
          output = main.execute("F3 F7").trim();
          matrix = getFieldMatrix(output);
          findShipByCoordinates(matrix, "F3 F7");
      
          if (!output.toLowerCase().contains("battleship")) {
            return CheckResult.wrong("After asking for the Aircraft Carrier coordinates, you should request " +
                    "the coordinates of the Battleship in that way:\n" +
                    "\"Enter the coordinates of the Battleship (4 cells):\"");
          }
      
          output = main.execute("A1 D1").trim();
          matrix = getFieldMatrix(output);
          findShipByCoordinates(matrix, "A1 D1");
      
          if (!output.toLowerCase().contains("submarine")) {
            return CheckResult.wrong("After asking for the Battleship coordinates, you should request " +
                    "the coordinates of the Submarine in that way:\n" +
                    "\"Enter the coordinates of the Submarine (3 cells):\"");
          }
      
          output = main.execute("J7 J10").trim();
          if (isGameFieldPrinted(output)) {
            return CheckResult.wrong("Your program should not print a game field if there is an input mistake.");
          }
      
          output = main.execute("J10 J8").trim();
          matrix = getFieldMatrix(output);
          findShipByCoordinates(matrix, "J10 J8");
      
          if (!output.toLowerCase().contains("cruiser")) {
            return CheckResult.wrong("After asking for the Submarine coordinates, you should request " +
                    "the coordinates of the Cruiser in that way:\n" +
                    "\"Enter the coordinates of the Cruiser (3 cells):\"");
          }
      
          output = main.execute("B9 D8").trim();
          if (isGameFieldPrinted(output)) {
            return CheckResult.wrong("Your program should not print a game field if there is an input mistake.");
          }
      
          output = main.execute("B9 D9").trim();
          matrix = getFieldMatrix(output);
          findShipByCoordinates(matrix, "B9 D9");
      
          if (!output.toLowerCase().contains("destroyer")) {
            return CheckResult.wrong("After asking for the Cruiser coordinates, you should request " +
                    "the coordinates of the Destroyer in that way:\n" +
                    "\"Enter the coordinates of the Destroyer (2 cells):\"");
          }
      
          output = main.execute("E6 D6").trim();
          if (isGameFieldPrinted(output)) {
            return CheckResult.wrong("Your program should not print a game field if there is an input mistake. " +
                    "(Too close to another ship)");
          }
      
          output = main.execute("I2 J2").trim();
          matrix = getFieldMatrix(output);
          findShipByCoordinates(matrix, "I2 J2");
      
          if (!output.toLowerCase().contains("enter")) {
            return CheckResult.wrong("No offer found to give the move to another player");
          }
      
          output = main.execute("");
      
          // Filling the second player field
      
          if (!output.toLowerCase().contains("aircraft carrier")) {
            return CheckResult.wrong("After filling the first player field, you should request the second player's " +
                    "coordinates of the Aircraft Carrier in that way:\n" +
                    "\"Enter the coordinates of the Aircraft Carrier (5 cells):\"");
          }
      
          output = main.execute("H2 H6");
          matrix = getFieldMatrix(output);
          findShipByCoordinates(matrix, "H2 H6");
      
          if (!output.toLowerCase().contains("battleship")) {
            return CheckResult.wrong("After asking for the Aircraft Carrier coordinates, you should request " +
                    "the coordinates of the Battleship in that way:\n" +
                    "\"Enter the coordinates of the Battleship (4 cells):\"");
          }
      
          output = main.execute("F3 F6");
          matrix = getFieldMatrix(output);
          findShipByCoordinates(matrix, "F3 F6");
      
          if (!output.toLowerCase().contains("submarine")) {
            return CheckResult.wrong("After asking for the Battleship coordinates, you should request " +
                    "the coordinates of the Submarine in that way:\n" +
                    "\"Enter the coordinates of the Submarine (3 cells):\"");
          }
      
          output = main.execute("H8 F8").trim();
          matrix = getFieldMatrix(output);
          findShipByCoordinates(matrix, "H8 F8");
      
          if (!output.toLowerCase().contains("cruiser")) {
            return CheckResult.wrong("After asking for the Submarine coordinates, you should request " +
                    "the coordinates of the Cruiser in that way:\n" +
                    "\"Enter the coordinates of the Cruiser (3 cells):\"");
          }
      
          output = main.execute("D4 D6").trim();
          matrix = getFieldMatrix(output);
          findShipByCoordinates(matrix, "D4 D6");
      
          if (!output.toLowerCase().contains("destroyer")) {
            return CheckResult.wrong("After asking for the Cruiser coordinates, you should request " +
                    "the coordinates of the Destroyer in that way:\n" +
                    "\"Enter the coordinates of the Destroyer (2 cells):\"");
          }
      
          output = main.execute("D8 C8");
          matrix = getFieldMatrix(output);
          findShipByCoordinates(matrix, "D8 C8");
      
          if (!output.toLowerCase().contains("enter")) {
            return CheckResult.wrong("no offer found to give the move to another player");
          }
          output = main.execute("");
      
          // Players' moves
          String[] splittedOutput = output.split("---\n");
          if (splittedOutput.length != 2) {
            return CheckResult.wrong("An incorrect number of game fields.\nThere should be 2 fields separated by dashed line");
          }
          if (!matrixIsEmpty(getFieldMatrix(splittedOutput[0]))) {
            return CheckResult.wrong("At the start of the game the upper field should be empty");
          }
          findAllShips(getFieldMatrix(splittedOutput[1]),
                  new String[]{"F3 F7", "A1 D1", "J10 J8", "B9 D9", "I2 J2"});
      
          output = main.execute("I3");
          if (!output.toLowerCase().contains("missed")) {
            return CheckResult.wrong("Incorrect reaction of the program if the player missed");
          }
      
          output = main.execute("");
          checkMissing(getFieldMatrix(output), "I3");
      
          splittedOutput = output.split("---\n");
          if (splittedOutput.length != 2) {
            return CheckResult.wrong("An incorrect number of game fields (2 should be)");
          }
          if (!matrixIsEmpty(getFieldMatrix(splittedOutput[0]))) {
            return CheckResult.wrong("At the start of the game the upper field should be empty");
          }
          findAllShips(getFieldMatrix(splittedOutput[1]),
                  new String[]{"H2 H6", "F3 F6", "H8 F8", "D4 D6", "D8 C8"});
      
          output = main.execute("C9");
          if (!output.toLowerCase().contains("hit")) {
            return CheckResult.wrong("Incorrect reaction of the program if the player hit the ship");
          }
          main.execute("");
      
          makeMoveTillTheEnd(main);
      
          return CheckResult.correct();
        }
      
        void makeMoveTillTheEnd(TestedProgram main) {
      
          String[] secondPlayerMoves = {"A1", "B1", "C1", "D1", "B9", "C9", "D9", "F3", "F4", "F5", "F6", "F7", "I2", "J2", "J8", "J9", "J10"};
          String[] firstPlayerMoves = {"D4", "D5", "D6", "C8", "D8", "F3", "F4", "F5", "F6", "F7", "D10", "E10", "F10", "G10", "J1", "J2", "J3"};
      
          String[][] matrix;
          String output;
          int i;
      
          for (i = 0; i < 3; i++) {
            main.execute(firstPlayerMoves[i]);
            main.execute("");
            main.execute(secondPlayerMoves[i]);
            main.execute("");
          }
      
          main.execute(firstPlayerMoves[i]);
          main.execute("");
      
          output = main.execute(secondPlayerMoves[i]);
          if (!output.contains("sank")) {
            throw new WrongAnswer("After a ship was sunk you should print \"You sank a ship!\" and ask to press Enter.");
          }
          output = main.execute("");
      
          String[] splittedOutput = output.split("---\n");
          if (splittedOutput.length != 2) {
            throw new WrongAnswer("An incorrect number of game fields.\nThere should be 2 fields separated by dashed line");
          }
      
          matrix = getFieldMatrix(splittedOutput[1]);
          checkShot(matrix, "A1");
          checkShot(matrix, "B1");
          checkShot(matrix, "C1");
          checkShot(matrix, "D1");
      
          for (i = i + 1; i < secondPlayerMoves.length - 1; i++) {
            main.execute(firstPlayerMoves[i]);
            main.execute("");
            main.execute(secondPlayerMoves[i]);
            main.execute("");
          }
      
          main.execute(firstPlayerMoves[i]);
          main.execute("");
          output = main.execute(secondPlayerMoves[i]).toLowerCase();
      
          if (!output.contains("won") || !output.contains("congratulations")) {
            throw new WrongAnswer("If a player has sunk all enemy ships you should print:\n" +
                    "\"You sank the last ship. You won. Congratulations!\"");
          }
        }
      
        void findShipByCoordinates(String[][] matrix, String coordinates) {
          int[] coordinatesInt = parseCoordinates(coordinates);
      
          if (coordinatesInt[0] > coordinatesInt[2]) {
            int swap = coordinatesInt[0];
            coordinatesInt[0] = coordinatesInt[2];
            coordinatesInt[2] = swap;
          } else if (coordinatesInt[1] > coordinatesInt[3]) {
            int swap = coordinatesInt[1];
            coordinatesInt[1] = coordinatesInt[3];
            coordinatesInt[3] = swap;
          }
      
          if (coordinatesInt[0] == coordinatesInt[2]) {
            int cord = coordinatesInt[0];
            for (int i = coordinatesInt[1]; i <= coordinatesInt[3]; i++) {
              if (!matrix[cord][i].toLowerCase().equals("x") && !matrix[cord][i].toLowerCase().equals("o")) {
                throw new WrongAnswer("The ship's cells were not found at the coordinates \"" + coordinates + "\"");
              }
            }
          } else {
            int cord = coordinatesInt[1];
            for (int i = coordinatesInt[0]; i <= coordinatesInt[2]; i++) {
              if (!matrix[i][cord].toLowerCase().equals("x") && !matrix[i][cord].toLowerCase().equals("o")) {
                throw new WrongAnswer("The ship's cells were not found at the \"" + coordinates + "\"");
              }
            }
          }
        }
      
        boolean matrixIsEmpty(String[][] matrix) {
          for (String[] strings : matrix) {
            for (int j = 0; j < matrix.length; j++) {
              if (!strings[j].trim().equals("~")) {
                return false;
              }
            }
          }
          return true;
        }
      
        void checkShot(String[][] matrix, String coordinate) {
          int[] parsedCoordinate = new int[2];
          parsedCoordinate[0] = charToInt(coordinate.toLowerCase().substring(0, 1));
          parsedCoordinate[1] = Integer.parseInt(coordinate.substring(1)) - 1;
      
          if (!matrix[parsedCoordinate[0]][parsedCoordinate[1]].toLowerCase().contains("x")) {
            throw new WrongAnswer("Expected hit in \"" + coordinate + "\".");
          }
        }
      
        boolean checkMissing(String[][] matrix, String coordinate) {
          int[] parsedCoordinate = new int[2];
          parsedCoordinate[0] = charToInt(coordinate.toLowerCase().substring(0, 1));
          parsedCoordinate[1] = Integer.parseInt(coordinate.substring(1)) - 1;
      
          return matrix[parsedCoordinate[0]][parsedCoordinate[1]].toLowerCase().contains("m");
        }
      
        int[] parseCoordinates(String coordinatesString) {
          String[] splittedCoords = coordinatesString.split(" ");
          int[] parsedCoordinates = new int[4];
      
          parsedCoordinates[0] = charToInt(splittedCoords[0].substring(0, 1));
          parsedCoordinates[1] = Integer.parseInt(splittedCoords[0].substring(1)) - 1;
          parsedCoordinates[2] = charToInt(splittedCoords[1].substring(0, 1));
          parsedCoordinates[3] = Integer.parseInt(splittedCoords[1].substring(1)) - 1;
      
          return parsedCoordinates;
        }
      
        int charToInt(String charCoordinate) {
          charCoordinate = charCoordinate.toLowerCase();
          char character = charCoordinate.charAt(0);
          return (int) character - (int) 'a';
        }
      
        String[][] getFieldMatrix(String output) {
      
          WrongAnswer cantParseException = new WrongAnswer("Can't parse the game field\n" +
                  "Make sure you print it like in examples!");
      
          String[] splittedOutput = output.split("\n");
          String[][] matrix = new String[10][10];
      
          try {
            int index = 0;
            while (!(splittedOutput[index].contains("1") &&
                    splittedOutput[index].contains("2") &&
                    splittedOutput[index].contains("10"))) {
              index++;
              if (index > 1000) {
                throw cantParseException;
              }
            }
            index++;
      
            for (int i = 0; i < 10; i++) {
              String temp = splittedOutput[index].substring(2).trim();
              String[] splittedLine = temp.trim().split(" ");
              if (splittedLine.length != 10) {
                throw cantParseException;
              }
              matrix[i] = splittedLine;
              index++;
            }
          } catch (IndexOutOfBoundsException ignored) {
            throw cantParseException;
          }
      
          return matrix;
        }
      
        boolean isGameFieldPrinted(String output) {
          return output.contains("1") && output.contains("2") && output.contains("10");
        }
      
        void findAllShips(String[][] matrix, String[] coordinates) {
          for (String item : coordinates) {
            findShipByCoordinates(matrix, item);
          }
        }
      }
    learner_created: false
  - name: src/battleship/ship/ShipPlacementHandler.java
    visible: true
    text: |
      package battleship.ship;
      
      import java.util.List;
      
      public class ShipPlacementHandler {
      
          /**
           * Places the ship on the game screen using the character 'O'
           *
           * @param ship The ship to be placed
           * @param gameScreen The game screen to place the boat on.
           */
          public static void placeShip(Ship ship, char[][] gameScreen) {
              // For each position of the coordinate, add them to the map
              for (String position : ship.getPositions()) {
                  int row = position.charAt(0) - 'A';
                  int col = Integer.parseInt(position.substring(1)) - 1; // Adjusted for 0-based index
      
                  // Add them to the game screen
                  gameScreen[row][col] = 'O';
              }
      
          }
      
      
      }
    learner_created: true
  - name: src/battleship/shooting/ShootingValidator.java
    visible: true
    text: |
      package battleship.shooting;
      
      import battleship.io.input.UserInputHandler;
      import battleship.validation.BaseValidation;
      
      public class ShootingValidator extends BaseValidation {
      
          /**
           * Handles the logic to check if a shot is valid.
           *
           * @param coordinate The coordinate to validate.
           * @param gameScreen The game screen to check.
           * @return True if it a valid shot; false otherwise.
           */
          public static boolean isValidShot(String coordinate, char[][] gameScreen) {
              if (!isValidCoordinate(coordinate)) {
                  System.out.println("Error! Coordinate must be within the bounds of the map");
                  return false;
              }
      
      //        if (isHit(coordinate, gameScreen)) {
      //            System.out.println("Error! Coordinate has previously been selected");
      //            return false;
      //        }
              return true;
          }
      
          /**
           * Validates the coordinate is the correct length and within the bounds of the game
           *
           * @param coordinate The coordinate to validate
           * @return True if it is a valid coordinate; false otherwise
           */
          private static boolean isValidCoordinate(String coordinate) {
              if (coordinate.length() > 3) {
                  return false;
              }
      
              char row = coordinate.charAt(0);
              int col = UserInputHandler.parseInt(coordinate.substring(1));
      
              if (!isWithinBounds(row, col)) {
                  return false;
              }
      
              return true;
          }
      
          /**
           * Checks if the coordinate has previously been selected.
           *
           * @param coordinate The coordinate to check
           * @param gameScreen The game screen to check
           * @return True if there is a 'X' or an 'M' at the coordinate; false otherwise
           */
          private static boolean isHit(String coordinate, char[][] gameScreen) {
              int row = coordinate.charAt(0) - 'A';
              int col = Integer.parseInt(coordinate.substring(1)) - 1;
      
              // X is a hit and M is a miss
              return gameScreen[row][col] == 'X' || gameScreen[row][col] == 'M';
          }
      }
    learner_created: true
  - name: src/battleship/main/Runner.java
    visible: true
    text: |
      package battleship.main;
      
      import battleship.game.PlayGame;
      
      public class Runner {
      
          public static void main(String[] args) {
              PlayGame playGame = new PlayGame();
              playGame.playGame();
          }
      }
    learner_created: true
  - name: src/battleship/io/input/UserInputValidator.java
    visible: true
    text: |
      package battleship.io.input;
      
      public class UserInputValidator {
      
          /**
           * Checks if the input is null or empty
           *
           * @param input The input to be checked
           * @return True if it is null or empty; false otherwise
           */
          public static boolean isNullOrEmpty(String input) {
              return input == null || input.equals("");
          }
      }
    learner_created: true
  - name: src/battleship/ship/ShipPlacementValidator.java
    visible: true
    text: |
      package battleship.ship;
      
      import battleship.io.input.UserInputHandler;
      import battleship.validation.BaseValidation;
      
      import java.util.ArrayList;
      import java.util.List;
      
      public class ShipPlacementValidator extends BaseValidation {
      
          /**
           * Holds the logic to make sure the ship placement follows the rules of the game. The
           * coordinates are checked to make sure they are within the bounds of the game. These
           * coordinates are then checked to ensure the boat placement is either vertical or
           * horizontal, it is then checked that the boat would not be touching or overlapping with
           * another boat. Finally, the boat is checked to make sure it is the required length.
           *
           * @param start The starting coordinate
           * @param end The ending coordinate
           * @param shipType The ship type to be placed
           * @param gameBoard The game board to be referenced.
           * @return True if it is a valid placement; false otherwise.
           */
          public static boolean isValidCoordinates(String start, String end,
                                                   ShipType shipType, char[][] gameBoard) {
              // If the length of the coordinates given are incorrect, return
              if (!isValidLength(start, end)) {
                  System.out.println("Error! Coordinates must be between 2-3 characters each");
                  return false;
              }
      
              // Parse the start and end coordinates
              char startRow = start.charAt(0);
              // Gets the numbers that are double digits
              int startCol = UserInputHandler.parseInt(start.substring(1));
              char endRow = end.charAt(0);
              int endCol = UserInputHandler.parseInt(end.substring(1));
      
              // Make sure they are letters from 'A' to 'J' and numbers from 1-10
              if ((!isWithinBounds(startRow, startCol)) || (!isWithinBounds(endRow, endCol))) {
                  System.out.println("Error! Coordinates must be within the bounds of the game. 'A' to " +
                          " 'J' and 1-10");
                  return false;
              }
      
              // Make sure the direction is vertical or horizontal
              if ((!isHorizontal(startRow, endRow) && (!isVertical(startCol, endCol)))) {
                  System.out.println("Error! Placement cannot be diagonal");
                  return false;
              }
      
              // Does not overlap with another boat
              if (isOverlapping(startRow, startCol, endRow, endCol, gameBoard)) {
                  System.out.println("Error! Ship placement cannot overlap with another ship");
                  return false;
              }
      
              // Does not touch another boat
              if (isTouching(startRow, startCol, endRow, endCol, gameBoard)) {
                  System.out.println("Error! Ship placement cannot touch another ship");
                  return false;
              }
      
              // Is the required ship length
              if (!isCorrectLength(startRow, startCol, endRow, endCol, shipType)) {
                  System.out.println("Error! Ship must be of length " + shipType.getLength());
                  return false;
              }
              return true;
          }
      
          /**
           * Checks to make sure the length of the coordinates is the same as the required length fot
           * the current ship.
           *
           * @param startRow The starting coordinate for the row
           * @param startCol The starting coordinate for the col
           * @param endRow   The ending coordinate for the row
           * @param endCol   The ending coordinate for the col
           * @param shipType The ship to be compared to.
           * @return True of the lengths match; false otherwise
           */
          private static boolean isCorrectLength(char startRow, int startCol, char endRow, int endCol,
                                                 ShipType shipType) {
              // Required length for ship placement
              int requiredLength = shipType.getLength();
      
              // Length of coordinates
              int coordinateLength = -1;
      
              // Get orientation
              if (startRow == endRow) { // Horizontal placement
                  coordinateLength = Math.abs(startCol - endCol) + 1; // Plus one to include all the spaces
              } else { // Vertical placement
                  coordinateLength = Math.abs(startRow - endRow) + 1; // Plus one to include all the
                  // spaces
              }
              return requiredLength == coordinateLength;
          }
      
      }
    learner_created: true
  - name: src/battleship/validation/BaseValidation.java
    visible: true
    text: |
      package battleship.validation;
      
      import java.util.ArrayList;
      import java.util.List;
      
      public class BaseValidation {
          private static final List<Character> POSSIBLE_ROWS = createPossibleRowOptions();
          private static final List<Integer> POSSIBLE_COLUMNS = createPossibleColumnOptions();
      
      
          /**
           * Makes sure the start and end coordinates are at least two characters in length and no more
           * than 3 characters in length
           *
           * @param start The starting coordinates to check
           * @param end   The ending coordinates to check
           * @return True if the start and end are both at least length two but no greater than 3.
           */
          protected static boolean isValidLength(String start, String end) {
              return (start != null) && (end != null) &&
                      (start.length() >= 2) && (end.length() >= 2 &&
                      (start.length() <= 3) && (end.length() <= 3));
          }
      
          /**
           * Checks if the row and col provided matches a possible row and column of the game.
           *
           * @param row The row to be checked
           * @param col The column to be checked
           * @return True if it is within the bounds of the game field; false otherwise.
           */
          protected static boolean isWithinBounds(char row, int col) {
              return POSSIBLE_ROWS.contains(row) && POSSIBLE_COLUMNS.contains(col);
          }
      
          /**
           * Checks to make sure the ship placement is vertical
           *
           * @param startCol The starting col coordinates
           * @param endCol   The ending col coordinates
           * @return True if the placement is vertical; false otherwise.
           */
          protected static boolean isVertical(int startCol, int endCol) {
              return (startCol == endCol);
      
          }
      
          /**
           * Checks to make sure the ship placement is horizontal
           *
           * @param startRow The starting row coordinates
           * @param endRow   The ending row coordinates
           * @return True if the placement is horizontal; false otherwise
           */
          protected static boolean isHorizontal(char startRow, char endRow) {
              return (startRow == endRow);
          }
      
          /**
           * Checks to see if the boat placement is overlapping with another boat.
           *
           * @param startRow  The start row coordinate
           * @param startCol  The start col coordinate
           * @param endRow    The end row coordinate
           * @param endCol    The end col coordinate
           * @param gameBoard The game board to check
           * @return True if it is overlapping; false otherwise
           */
          protected static boolean isOverlapping(char startRow, int startCol, char endRow, int endCol,
                                               char[][] gameBoard) {
      
              // Convert row characters to zero-based indices for array access
              int startRowIndex = startRow - 'A';
              int endRowIndex = endRow - 'A';
      
              // If the placement is horizontal
              if (isHorizontal(startRow, endRow)) {
                  // Get the min and max coordinates to ensure the loop works correctly
                  int min = Math.min(startCol, endCol);
                  int max = Math.max(startCol, endCol);
      
                  // Iterate through the columns in the specified range
                  for (int col = min; col <= max; col++) {
                      // Check if the cell is occupied
                      if (gameBoard[startRowIndex][col - 1] != '~') {
                          return true;
                      }
                  }
              } else { // Vertical Placement
                  // Get the min and max coordinates to ensure the loop works correctly
                  int min = Math.min(startRowIndex, endRowIndex);
                  int max = Math.max(startRowIndex, endRowIndex);
      
                  // Iterate through the rows in the specified range
                  for (int row = min; row <= max; row++) {
                      // Check if the cell is occupied
                      if (gameBoard[row][startCol - 1] != '~') {
                          return true;
                      }
                  }
              }
              return false; // False if no overlap is found
          }
      
          /**Checks if the boat placement would be touching another boat.
           *
           * @param startRow  The start row coordinate
           * @param startCol  The start col coordinate
           * @param endRow    The end row coordinate
           * @param endCol    The end col coordinate
           * @param gameBoard The game board to check
           * @return True if the boat placement is touching another boat; false otherwise.
           */
          protected static boolean isTouching(char startRow, int startCol, char endRow, int endCol,
                                            char[][] gameBoard) {
              int startRowIndex = startRow - 'A';
              int endRowIndex = endRow - 'A';
      
              // Plus 1 and minus 1 to include the row or column just before the ship
              int minRow = Math.min(startRowIndex, endRowIndex) - 1;
              int maxRow = Math.max(startRowIndex, endRowIndex) + 1;
              int minCol = Math.min(startCol, endCol) - 1;
              int maxCol = Math.max(startCol, endCol) + 1;
      
              // Iterate over the surrounding cells
              for (int row = Math.max(0, minRow); row <= Math.min(9, maxRow); row++) {
                  for (int col = Math.max(0, minCol); col <= Math.min(9, maxCol); col++) {
                      if (gameBoard[row][col] == 'O') {
                          return true;
                      }
                  }
              }
      
              return false; // False if no touching if found
          }
      
          /**
           * Creates possible row options from 'A' to 'J'
           *
           * @return A List<Character> of chars filled from 'A' to 'J'
           */
          private static List<Character> createPossibleRowOptions() {
              // Possible rows options. 'A' to 'J'
              List<Character> possibleRows = new ArrayList<>();
              for (char i = 'A'; i <= 'J'; i++) {
                  possibleRows.add(i);
              }
              return possibleRows;
          }
      
          /**
           * Creates possible column options from '1' to '10'
           *
           * @return A List<Integer> of chars filled from '1' to '10'
           */
          private static List<Integer> createPossibleColumnOptions() {
              // Possible rows options. '1' to '10'
              List<Integer> possibleColumns = new ArrayList<>();
              for (int i = 1; i <= 10; i++) {
                  possibleColumns.add(i);
              }
              return possibleColumns;
          }
      }
    learner_created: true
  - name: src/battleship/ship/ShipType.java
    visible: true
    text: |
      package battleship.ship;
      
      public enum ShipType {
          AIRCRAFT_CARRIER("Aircraft Carrier", 5),
          BATTLESHIP("Battleship", 4),
          SUBMARINE("Submarine", 3),
          CRUISER("Cruiser", 3),
          DESTROYER("Destroyer", 2);
      
          // INSTANCE VARIABLES
          private final String name;
          private final int length;
      
          // GETTERS AND SETTERS
          public String getName() {
              return name;
          }
      
          public int getLength() {
              return length;
          }
      
          // CONSTRUCTOR
          ShipType(String name, int length) {
              this.name = name;
              this.length = length;
          }
      }
    learner_created: true
  - name: src/battleship/shooting/UpdateShot.java
    visible: true
    text: |
      package battleship.shooting;
      
      import battleship.io.input.UserInputHandler;
      
      public class UpdateShot {
      
          /**
           * The map is updated using 'X' for a hit and 'M' for a miss
           *
           * @param coordinate The coordinates of the shot
           * @param gameScreen The game screen to update
           */
          public static void updateShot(String coordinate, char[][] gameScreen, char[][] fogOfWarScreen) {
              int row = coordinate.charAt(0) - 'A';
              int col = UserInputHandler.parseInt(coordinate.substring(1)) - 1;
      
              // If there is a boat at the coordinate, place an 'X'
              if (gameScreen[row][col] == 'O') {
                  fogOfWarScreen[row][col] = 'X';
                  System.out.println("You hit a ship! Try again: ");
              } else { // Place M for a miss
                  fogOfWarScreen[row][col] = 'M';
                  System.out.println("You missed. Try again: ");
              }
          }
      }
    learner_created: true
  - name: src/battleship/gameScreen/CreateGameScreen.java
    visible: true
    text: |
      package battleship.gameScreen;
      
      public class CreateGameScreen {
          // INSTANCE VARIABLES
          private char[][] gameScreen;
      
          // GETTERS AND SETTERS
      
      
          public char[][] getGameScreen() {
              return gameScreen;
          }
      
          public void setGameScreen(char[][] gameScreen) {
              this.gameScreen = gameScreen;
          }
      
          // CONSTRUCTORS
          public CreateGameScreen() {
              // Row for column and row labels
              gameScreen = new char[10][10];
              initialiseGameScreen();
          }
      
          // METHODS
          private void initialiseGameScreen() {
              // Add tilde
              addTilde();
          }
      
          private void addTilde() {
              for (int row = 0; row < gameScreen.length; row++) {
                  for (int col = 0; col < gameScreen[row].length; col++) {
                      gameScreen[row][col] = '~';
                  }
              }
          }
      
      
      
      
      }
    learner_created: true
  - name: src/battleship/ship/Ship.java
    visible: true
    text: |
      package battleship.ship;
      
      import battleship.io.input.UserInputHandler;
      
      import java.util.ArrayList;
      import java.util.List;
      
      public class Ship {
      
          // INSTANCE VARIABLES
          private int length;
          private List<String> positions;
      
          // GETTERS AND SETTERS
          public int getLength() {
              return length;
          }
      
          public void setLength(int length) {
              this.length = length;
          }
      
          public List<String> getPositions() {
              return positions;
          }
      
          public void setPositions(List<String> positions) {
              this.positions = positions;
          }
      
          // CONSTRUCTOR
          public Ship(String start, String end) {
              this.positions = new ArrayList<>();
              calculatePositions(start, end);
              this.length = positions.size();
          }
      
      
          /**
           * Uses the coordinates provided to calculate all the positions taken up by the boat.
           *
           * @param start The starting coordinates for the ship
           * @param end The ending coordinates for the ship
           */
          private void calculatePositions(String start, String end) {
              // Separate the coordinates.
              char startRow = start.charAt(0);
              int startCol = UserInputHandler.parseInt(start.substring(1));
              char endRow = end.charAt(0);
              int endCol = UserInputHandler.parseInt(end.substring(1));
      
              // Check Orientation
              if (startRow == endRow) { // Horizontal placement
                  // Find the min and max coordinates to the loop runs correctly
                  int min = Math.min(startCol, endCol);
                  int max = Math.max(startCol, endCol);
      
                  for (int col = min; col <= max; col++) {
                      // Add empty string to concatenate
                      positions.add("" + startRow + col);
                  }
              } else { // Vertical placement
                  // Find the min and max coordinates to the loop runs correctly
                  char min = (char) Math.min(startRow, endRow);
                  char max = (char) Math.max(startRow, endRow);
      
                  for (char row = min; row <= max; row++) {
                      positions.add("" + row + startCol);
                  }
              }
          }
      
      
      }
    learner_created: true
  - name: src/battleship/io/output/DisplayGameScreen.java
    visible: true
    text: "package battleship.io.output;\n\npublic class DisplayGameScreen {\n\n\n \
    \   /**\n     * Displays the game screen in the terminal/\n     *\n     * @param\
    \ gameScreen The current game screen to be printed.\n     */\n    public static\
    \ void displayGameScreen(char[][] gameScreen) {\n        System.out.println(createPrintableGameScreen(gameScreen));\n\
    \    }\n\n    /**\n     * Create a string of the current game screen. Row labels\
    \ of 'A' to 'J' are added and column\n     * labels of 1-10 are added also.\n\
    \     *\n     * @param gameScreen The game screen to be adjusted.\n     * @return\
    \ The game screen as a string\n     */\n    private static String createPrintableGameScreen(char[][]\
    \ gameScreen) {\n        StringBuilder gameScreenPrint = new StringBuilder();\n\
    \n        gameScreenPrint.append(\"  \"); // Top left corner is empty with two\
    \ spaces\n\n        // Append col labels\n        for (int col = 1; col <= gameScreen[0].length;\
    \ col++) {\n            gameScreenPrint.append(col).append(\" \");\n        }\n\
    \        gameScreenPrint.append(\"\\n\");\n        \n        // Append Row labels\
    \ and Row information\n        for (int row = 0; row < gameScreen.length; row++)\
    \ {\n            // Add the Row labels\n            gameScreenPrint.append((char)\
    \ ('A' + row)).append(\" \");\n            for (int col = 0; col < gameScreen[row].length;\
    \ col++) {\n                gameScreenPrint.append(gameScreen[row][col]).append(\"\
    \ \");\n            }\n            gameScreenPrint.append(\"\\n\");\n        }\n\
    \        return gameScreenPrint.toString();\n    }\n}\n"
    learner_created: true
  - name: src/battleship/game/PlayGame.java
    visible: true
    text: |
      package battleship.game;
      
      import battleship.gameScreen.CreateGameScreen;
      import battleship.io.input.UserInputHandler;
      import battleship.io.input.UserInputValidator;
      import battleship.io.output.DisplayGameScreen;
      import battleship.ship.Ship;
      import battleship.ship.ShipPlacementHandler;
      import battleship.ship.ShipPlacementValidator;
      import battleship.ship.ShipType;
      import battleship.shooting.ShootingValidator;
      import battleship.shooting.UpdateShot;
      
      import java.util.ArrayList;
      import java.util.List;
      
      public class PlayGame {
      
          private CreateGameScreen gameScreen;
          private CreateGameScreen fogOfWar;
          private List<Ship> listOfShips;
      
          public PlayGame() {
              // Generates a blank game field
              this.gameScreen = new CreateGameScreen();
              this.fogOfWar = new CreateGameScreen();
              this.listOfShips = new ArrayList<>();
          }
      
          public void playGame() {
              // Displays the blank≠ game field
              DisplayGameScreen.displayGameScreen(gameScreen.getGameScreen());
      
              // User will place all ships in a valid location.
              placeShips();
      
              System.out.println("The game starts!");
      
              // Displays the blank game screen
              DisplayGameScreen.displayGameScreen(fogOfWar.getGameScreen());
      
              // While all ships are not sunk
              while (!allShipsSunk()) {
                  // User is promoted to take a shot
                  takeShot();
      
                  // Displays the blank game screen
                  DisplayGameScreen.displayGameScreen(fogOfWar.getGameScreen());
              }
      
              // All ships sank
              System.out.println("You sank the last ship. You won. Congratulations!");
          }
      
          private void placeShips() {
              // Loops through each ship type
              for (ShipType shipType : ShipType.values()) {
                  // A flag keep track if the ship has been placed
                  boolean validPlacement = false;
                  while (!validPlacement) {
      
                      // Prompt the user to enter the coordinates for the current ship
                      System.out.println("Enter the coordinates of the " + shipType.getName() + " (" + shipType.getLength() + " cells): ");
                      String userInput = UserInputHandler.getUserString();
      
                      // User input must not be empty or null
                      if (UserInputValidator.isNullOrEmpty(userInput)) {
                          System.out.println("Error! Coordinates must be provided.");
                          continue;
                      }
      
                      // Separate the coordinates
                      String[] coordinates = userInput.split(" ");
      
                      // Must be only two coordinates given
                      if (coordinates.length == 2) {
      
                          // Start and end coordinates for ship placement
                          String start = coordinates[0];
                          String end = coordinates[1];
      
                          // Validate coordinates
                          if (ShipPlacementValidator.isValidCoordinates(start, end,
                                  shipType, gameScreen.getGameScreen())) {
                              // Create the ship to be placed
                              Ship ship = new Ship(start, end);
                              ShipPlacementHandler.placeShip(ship, gameScreen.getGameScreen());
      
                              // Add the ship to the list of ships
                              listOfShips.add(ship);
      
                              // Update the valid placement to true
                              validPlacement = true;
      
                              // Displays the blank game field
                              DisplayGameScreen.displayGameScreen(gameScreen.getGameScreen());
      
                          }
      
                      } else {
                          System.out.println("Error: Invalid input format. Please enter two coordinates.");
                      }
      
                  }
      
              }
          }
      
          private void takeShot() {
              boolean validShot = false;
              while (!validShot) {
                  System.out.println("Take a shot!");
      
                  String coordinate = UserInputHandler.getUserString();
      
                  // User input must not be empty or null
                  if (UserInputValidator.isNullOrEmpty(coordinate)) {
                      System.out.println("Error! Coordinates must be provided.");
                      continue; // Prompt again
                  }
      
      
                  // Must be only two coordinates given
                  if (coordinate.length() > 1) {
      
                      // Validate coordinates
                      if (ShootingValidator.isValidShot(coordinate, gameScreen.getGameScreen())) {
      
                          // Update the game screen with the correct symbol
                          UpdateShot.updateShot(coordinate, gameScreen.getGameScreen(),
                                  fogOfWar.getGameScreen());
      
                          Ship hitShip = findHitShip(coordinate);
                          if (hitShip != null && isShipSunk(hitShip)) {
                              System.out.println("You sank a ship! Specify a new target:");
                          }
      
                          // Update the valid shot flag
                          validShot = true;
                      }
      
                  } else {
                      System.out.println("Error: Invalid input format. Please enter one coordinates.");
                  }
              }
          }
      
          private boolean allShipsSunk() {
              for (Ship ship : listOfShips) {
                  if (!isShipSunk(ship)) {
                      return false;
                  }
              }
              return true;
          }
      
          private boolean isShipSunk(Ship ship) {
              for (String position : ship.getPositions()) {
                  int row = position.charAt(0) - 'A';
                  int col = UserInputHandler.parseInt(position.substring(1)) - 1;
      
                  if (fogOfWar.getGameScreen()[row][col] != 'X') {
                      return false;
                  }
              }
              return true;
          }
      
          private Ship findHitShip(String coordinate) {
              for (Ship ship : listOfShips) {
                  if (ship.getPositions().contains(coordinate)) {
                      return ship;
                  }
              }
              return null;
          }
      }
    learner_created: true
  - name: src/battleship/io/input/UserInputHandler.java
    visible: true
    text: |
      package battleship.io.input;
      
      import java.util.InputMismatchException;
      import java.util.Scanner;
      
      public class UserInputHandler {
          private static final Scanner SCANNER = new Scanner(System.in);
      
          /**
           * Gets the input from the user as a String
           * @return The users input as a string.
           */
          public static String getUserString() {
              return SCANNER.nextLine();
          }
      
          /**
           * Ensures the input is an int
           * @param input The String to be parsed to an int
           * @return The int if it can be parsed or -1.
           */
          public static int parseInt(String input) {
              int integer = -1;
              try {
                  integer = Integer.parseInt(input);
              }catch (NumberFormatException e) {
                  System.out.println("Must be a number from 1-10");
              }
              return integer;
          }
      }
    learner_created: true
  - name: src/battleship/player/Player.java
    visible: true
    learner_created: true
  - name: src/battleship/ship/ShipSunkHandler.java
    visible: true
    learner_created: true
feedback_link: https://hyperskill.org/learn/step/35309#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">Hyperskill</a>
    to continue learning.
  time: "Thu, 01 Aug 2024 20:57:19 UTC"
record: -1
